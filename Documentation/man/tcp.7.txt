TCP(7)                               Linux Programmer's Manual                               TCP(7)



NNAAMMEE
       tcp - TCP protocol

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ssyyss//ssoocckkeett..hh>>
       ##iinncclluuddee <<nneettiinneett//iinn..hh>>
       ##iinncclluuddee <<nneettiinneett//ttccpp..hh>>

       ttccpp__ssoocckkeett == ssoocckkeett((AAFF__IINNEETT,, SSOOCCKK__SSTTRREEAAMM,, 00));;

DDEESSCCRRIIPPTTIIOONN
       This is an implementation of the TCP protocol defined in RFC 793, RFC 1122 and RFC 2001 with
       the NewReno and SACK extensions.  It provides a reliable, stream-oriented, full-duplex
       connection between two sockets on top of iipp(7), for both v4 and v6 versions.  TCP guarantees
       that the data arrives in order and retransmits lost packets.  It generates and checks a per-
       packet checksum to catch transmission errors.  TCP does not preserve record boundaries.

       A newly created TCP socket has no remote or local address and is not fully specified.  To
       create an outgoing TCP connection use ccoonnnneecctt(2) to establish a connection to another TCP
       socket.  To receive new incoming connections, first bbiinndd(2) the socket to a local address
       and port and then call lliisstteenn(2) to put the socket into the listening state.  After that a
       new socket for each incoming connection can be accepted using aacccceepptt(2).  A socket which has
       had aacccceepptt(2) or ccoonnnneecctt(2) successfully called on it is fully specified and may transmit
       data.  Data cannot be transmitted on listening or not yet connected sockets.

       Linux supports RFC 1323 TCP high performance extensions.  These include Protection Against
       Wrapped Sequence Numbers (PAWS), Window Scaling and Timestamps.  Window scaling allows the
       use of large (> 64 kB) TCP windows in order to support links with high latency or bandwidth.
       To make use of them, the send and receive buffer sizes must be increased.  They can be set
       globally with the _/_p_r_o_c_/_s_y_s_/_n_e_t_/_i_p_v_4_/_t_c_p___w_m_e_m and _/_p_r_o_c_/_s_y_s_/_n_e_t_/_i_p_v_4_/_t_c_p___r_m_e_m files, or on
       individual sockets by using the SSOO__SSNNDDBBUUFF and SSOO__RRCCVVBBUUFF socket options with the
       sseettssoocckkoopptt(2) call.

       The maximum sizes for socket buffers declared via the SSOO__SSNNDDBBUUFF and SSOO__RRCCVVBBUUFF mechanisms are
       limited by the values in the _/_p_r_o_c_/_s_y_s_/_n_e_t_/_c_o_r_e_/_r_m_e_m___m_a_x and _/_p_r_o_c_/_s_y_s_/_n_e_t_/_c_o_r_e_/_w_m_e_m___m_a_x
       files.  Note that TCP actually allocates twice the size of the buffer requested in the
       sseettssoocckkoopptt(2) call, and so a succeeding ggeettssoocckkoopptt(2) call will not return the same size of
       buffer as requested in the sseettssoocckkoopptt(2) call.  TCP uses the extra space for administrative
       purposes and internal kernel structures, and the _/_p_r_o_c file values reflect the larger sizes
       compared to the actual TCP windows.  On individual connections, the socket buffer size must
       be set prior to the lliisstteenn(2) or ccoonnnneecctt(2) calls in order to have it take effect.  See
       ssoocckkeett(7) for more information.

       TCP supports urgent data.  Urgent data is used to signal the receiver that some important
       message is part of the data stream and that it should be processed as soon as possible.  To
       send urgent data specify the MMSSGG__OOOOBB option to sseenndd(2).  When urgent data is received, the
       kernel sends a SSIIGGUURRGG signal to the process or process group that has been set as the socket
       "owner" using the SSIIOOCCSSPPGGRRPP or FFIIOOSSEETTOOWWNN ioctls (or the POSIX.1-specified ffccnnttll(2) FF__SSEETTOOWWNN
       operation).  When the SSOO__OOOOBBIINNLLIINNEE socket option is enabled, urgent data is put into the
       normal data stream (a program can test for its location using the SSIIOOCCAATTMMAARRKK ioctl described
       below), otherwise it can be received only when the MMSSGG__OOOOBB flag is set for rreeccvv(2) or
       rreeccvvmmssgg(2).

       When out-of-band data is present, sseelleecctt(2) indicates the file descriptor as having an
       exceptional condition and _p_o_l_l _(_2_) indicates a PPOOLLLLPPRRII event.

       Linux 2.4 introduced a number of changes for improved throughput and scaling, as well as
       enhanced functionality.  Some of these features include support for zero-copy sseennddffiillee(2),
       Explicit Congestion Notification, new management of TIME_WAIT sockets, keep-alive socket
       options and support for Duplicate SACK extensions.

   AAddddrreessss ffoorrmmaattss
       TCP is built on top of IP (see iipp(7)).  The address formats defined by iipp(7) apply to TCP.
       TCP supports point-to-point communication only; broadcasting and multicasting are not
       supported.

   //pprroocc iinntteerrffaacceess
       System-wide TCP parameter settings can be accessed by files in the directory
       _/_p_r_o_c_/_s_y_s_/_n_e_t_/_i_p_v_4_/.  In addition, most IP _/_p_r_o_c interfaces also apply to TCP; see iipp(7).
       Variables described as _B_o_o_l_e_a_n take an integer value, with a nonzero value ("true") meaning
       that the corresponding option is enabled, and a zero value ("false") meaning that the option
       is disabled.

       _t_c_p___a_b_c (Integer; default: 0; Linux 2.6.15 to Linux 3.8)
              Control the Appropriate Byte Count (ABC), defined in RFC 3465.  ABC is a way of
              increasing the congestion window (_c_w_n_d) more slowly in response to partial
              acknowledgements.  Possible values are:

              0  increase _c_w_n_d once per acknowledgement (no ABC)

              1  increase _c_w_n_d once per acknowledgement of full sized segment

              2  allow increase _c_w_n_d by two if acknowledgement is of two segments to compensate for
                 delayed acknowledgements.

       _t_c_p___a_b_o_r_t___o_n___o_v_e_r_f_l_o_w (Boolean; default: disabled; since Linux 2.4)
              Enable resetting connections if the listening service is too slow and unable to keep
              up and accept them.  It means that if overflow occurred due to a burst, the
              connection will recover.  Enable this option _o_n_l_y if you are really sure that the
              listening daemon cannot be tuned to accept connections faster.  Enabling this option
              can harm the clients of your server.

       _t_c_p___a_d_v___w_i_n___s_c_a_l_e (integer; default: 2; since Linux 2.4)
              Count buffering overhead as _b_y_t_e_s_/_2_^_t_c_p___a_d_v___w_i_n___s_c_a_l_e, if _t_c_p___a_d_v___w_i_n___s_c_a_l_e is
              greater than 0; or _b_y_t_e_s_-_b_y_t_e_s_/_2_^_(_-_t_c_p___a_d_v___w_i_n___s_c_a_l_e_), if _t_c_p___a_d_v___w_i_n___s_c_a_l_e is less
              than or equal to zero.

              The socket receive buffer space is shared between the application and kernel.  TCP
              maintains part of the buffer as the TCP window, this is the size of the receive
              window advertised to the other end.  The rest of the space is used as the
              "application" buffer, used to isolate the network from scheduling and application
              latencies.  The _t_c_p___a_d_v___w_i_n___s_c_a_l_e default value of 2 implies that the space used for
              the application buffer is one fourth that of the total.

       _t_c_p___a_l_l_o_w_e_d___c_o_n_g_e_s_t_i_o_n___c_o_n_t_r_o_l (String; default: see text; since Linux 2.4.20)
              Show/set the congestion control algorithm choices available to unprivileged processes
              (see the description of the TTCCPP__CCOONNGGEESSTTIIOONN socket option).  The items in the list are
              separated by white space and terminated by a newline character.  The list is a subset
              of those listed in _t_c_p___a_v_a_i_l_a_b_l_e___c_o_n_g_e_s_t_i_o_n___c_o_n_t_r_o_l.  The default value for this list
              is "reno" plus the default setting of _t_c_p___c_o_n_g_e_s_t_i_o_n___c_o_n_t_r_o_l.

       _t_c_p___a_u_t_o_c_o_r_k_i_n_g (Boolean; default: enabled; since Linux 3.14)
              If this option is enabled, the kernel tries to coalesce small writes (from
              consecutive wwrriittee(2) and sseennddmmssgg(2) calls) as much as possible, in order to decrease
              the total number of sent packets.  Coalescing is done if at least one prior packet
              for the flow is waiting in Qdisc queues or device transmit queue.  Applications can
              still use the TTCCPP__CCOORRKK socket option to obtain optimal behavior when they know
              how/when to uncork their sockets.

       _t_c_p___a_v_a_i_l_a_b_l_e___c_o_n_g_e_s_t_i_o_n___c_o_n_t_r_o_l (String; read-only; since Linux 2.4.20)
              Show a list of the congestion-control algorithms that are registered.  The items in
              the list are separated by white space and terminated by a newline character.  This
              list is a limiting set for the list in _t_c_p___a_l_l_o_w_e_d___c_o_n_g_e_s_t_i_o_n___c_o_n_t_r_o_l.  More
              congestion-control algorithms may be available as modules, but not loaded.

       _t_c_p___a_p_p___w_i_n (integer; default: 31; since Linux 2.4)
              This variable defines how many bytes of the TCP window are reserved for buffering
              overhead.

              A maximum of (_w_i_n_d_o_w_/_2_^_t_c_p___a_p_p___w_i_n, mss) bytes in the window are reserved for the
              application buffer.  A value of 0 implies that no amount is reserved.

       _t_c_p___b_a_s_e___m_s_s (Integer; default: 512; since Linux 2.6.17)
              The initial value of _s_e_a_r_c_h___l_o_w to be used by the packetization layer Path MTU
              discovery (MTU probing).  If MTU probing is enabled, this is the initial MSS used by
              the connection.

       _t_c_p___b_i_c (Boolean; default: disabled; Linux 2.4.27/2.6.6 to 2.6.13)
              Enable BIC TCP congestion control algorithm.  BIC-TCP is a sender-side-only change
              that ensures a linear RTT fairness under large windows while offering both
              scalability and bounded TCP-friendliness.  The protocol combines two schemes called
              additive increase and binary search increase.  When the congestion window is large,
              additive increase with a large increment ensures linear RTT fairness as well as good
              scalability.  Under small congestion windows, binary search increase provides TCP
              friendliness.

       _t_c_p___b_i_c___l_o_w___w_i_n_d_o_w (integer; default: 14; Linux 2.4.27/2.6.6 to 2.6.13)
              Set the threshold window (in packets) where BIC TCP starts to adjust the congestion
              window.  Below this threshold BIC TCP behaves the same as the default TCP Reno.

       _t_c_p___b_i_c___f_a_s_t___c_o_n_v_e_r_g_e_n_c_e (Boolean; default: enabled; Linux 2.4.27/2.6.6 to 2.6.13)
              Force BIC TCP to more quickly respond to changes in congestion window.  Allows two
              flows sharing the same connection to converge more rapidly.

       _t_c_p___c_o_n_g_e_s_t_i_o_n___c_o_n_t_r_o_l (String; default: see text; since Linux 2.4.13)
              Set the default congestion-control algorithm to be used for new connections.  The
              algorithm "reno" is always available, but additional choices may be available
              depending on kernel configuration.  The default value for this file is set as part of
              kernel configuration.

       _t_c_p___d_m_a___c_o_p_y_b_r_e_a_k (integer; default: 4096; since Linux 2.6.24)
              Lower limit, in bytes, of the size of socket reads that will be offloaded to a DMA
              copy engine, if one is present in the system and the kernel was configured with the
              CCOONNFFIIGG__NNEETT__DDMMAA option.

       _t_c_p___d_s_a_c_k (Boolean; default: enabled; since Linux 2.4)
              Enable RFC 2883 TCP Duplicate SACK support.

       _t_c_p___e_c_n (Integer; default: see below; since Linux 2.4)
              Enable RFC 3168 Explicit Congestion Notification.

              This file can have one of the following values:

              0      Disable ECN.  Neither initiate nor accept ECN.  This was the default up to and
                     including Linux 2.6.30.

              1      Enable ECN when requested by incoming connections and also request ECN on
                     outgoing connection attempts.

              2      Enable ECN when requested by incoming connections, but do not request ECN on
                     outgoing connections.  This value is supported, and is the default, since
                     Linux 2.6.31.

              When enabled, connectivity to some destinations could be affected due to older,
              misbehaving middle boxes along the path, causing connections to be dropped.  However,
              to facilitate and encourage deployment with option 1, and to work around such buggy
              equipment, the ttccpp__eeccnn__ffaallllbbaacckk option has been introduced.

       _t_c_p___e_c_n___f_a_l_l_b_a_c_k (Boolean; default: enabled; since Linux 4.1)
              Enable RFC 3168, Section 6.1.1.1. fallback.  When enabled, outgoing ECN-setup SYNs
              that time out within the normal SYN retransmission timeout will be resent with CWR
              and ECE cleared.

       _t_c_p___f_a_c_k (Boolean; default: enabled; since Linux 2.2)
              Enable TCP Forward Acknowledgement support.

       _t_c_p___f_i_n___t_i_m_e_o_u_t (integer; default: 60; since Linux 2.2)
              This specifies how many seconds to wait for a final FIN packet before the socket is
              forcibly closed.  This is strictly a violation of the TCP specification, but required
              to prevent denial-of-service attacks.  In Linux 2.2, the default value was 180.

       _t_c_p___f_r_t_o (integer; default: see below; since Linux 2.4.21/2.6)
              Enable F-RTO, an enhanced recovery algorithm for TCP retransmission timeouts (RTOs).
              It is particularly beneficial in wireless environments where packet loss is typically
              due to random radio interference rather than intermediate router congestion.  See RFC
              4138 for more details.

              This file can have one of the following values:

              0  Disabled.  This was the default up to and including Linux 2.6.23.

              1  The basic version F-RTO algorithm is enabled.

              2  Enable SACK-enhanced F-RTO if flow uses SACK.  The basic version can be used also
                 when SACK is in use though in that case scenario(s) exists where F-RTO interacts
                 badly with the packet counting of the SACK-enabled TCP flow.  This value is the
                 default since Linux 2.6.24.

              Before Linux 2.6.22, this parameter was a Boolean value, supporting just values 0 and
              1 above.

       _t_c_p___f_r_t_o___r_e_s_p_o_n_s_e (integer; default: 0; since Linux 2.6.22)
              When F-RTO has detected that a TCP retransmission timeout was spurious (i.e., the
              timeout would have been avoided had TCP set a longer retransmission timeout), TCP has
              several options concerning what to do next.  Possible values are:

              0  Rate halving based; a smooth and conservative response, results in halved
                 congestion window (_c_w_n_d) and slow-start threshold (_s_s_t_h_r_e_s_h) after one RTT.

              1  Very conservative response; not recommended because even though being valid, it
                 interacts poorly with the rest of Linux TCP; halves _c_w_n_d and _s_s_t_h_r_e_s_h immediately.

              2  Aggressive response; undoes congestion-control measures that are now known to be
                 unnecessary (ignoring the possibility of a lost retransmission that would require
                 TCP to be more cautious); _c_w_n_d and _s_s_t_h_r_e_s_h are restored to the values prior to
                 timeout.

       _t_c_p___k_e_e_p_a_l_i_v_e___i_n_t_v_l (integer; default: 75; since Linux 2.4)
              The number of seconds between TCP keep-alive probes.

       _t_c_p___k_e_e_p_a_l_i_v_e___p_r_o_b_e_s (integer; default: 9; since Linux 2.2)
              The maximum number of TCP keep-alive probes to send before giving up and killing the
              connection if no response is obtained from the other end.

       _t_c_p___k_e_e_p_a_l_i_v_e___t_i_m_e (integer; default: 7200; since Linux 2.2)
              The number of seconds a connection needs to be idle before TCP begins sending out
              keep-alive probes.  Keep-alives are sent only when the SSOO__KKEEEEPPAALLIIVVEE socket option is
              enabled.  The default value is 7200 seconds (2 hours).  An idle connection is
              terminated after approximately an additional 11 minutes (9 probes an interval of 75
              seconds apart) when keep-alive is enabled.

              Note that underlying connection tracking mechanisms and application timeouts may be
              much shorter.

       _t_c_p___l_o_w___l_a_t_e_n_c_y (Boolean; default: disabled; since Linux 2.4.21/2.6; obsolete since Linux
       4.14)  If enabled, the TCP stack makes decisions that prefer lower latency as opposed to
              higher throughput.  It this option is disabled, then higher throughput is preferred.
              An example of an application where this default should be changed would be a Beowulf
              compute cluster.  Since Linux 4.14, this file still exists, but its value is ignored.

       _t_c_p___m_a_x___o_r_p_h_a_n_s (integer; default: see below; since Linux 2.4)
              The maximum number of orphaned (not attached to any user file handle) TCP sockets
              allowed in the system.  When this number is exceeded, the orphaned connection is
              reset and a warning is printed.  This limit exists only to prevent simple denial-of-
              service attacks.  Lowering this limit is not recommended.  Network conditions might
              require you to increase the number of orphans allowed, but note that each orphan can
              eat up to ~64 kB of unswappable memory.  The default initial value is set equal to
              the kernel parameter NR_FILE.  This initial default is adjusted depending on the
              memory in the system.

       _t_c_p___m_a_x___s_y_n___b_a_c_k_l_o_g (integer; default: see below; since Linux 2.2)
              The maximum number of queued connection requests which have still not received an
              acknowledgement from the connecting client.  If this number is exceeded, the kernel
              will begin dropping requests.  The default value of 256 is increased to 1024 when the
              memory present in the system is adequate or greater (>= 128 MB), and reduced to 128
              for those systems with very low memory (<= 32 MB).

              Prior to Linux 2.6.20, it was recommended that if this needed to be increased above
              1024, the size of the SYNACK hash table (TTCCPP__SSYYNNQQ__HHSSIIZZEE) in _i_n_c_l_u_d_e_/_n_e_t_/_t_c_p_._h should
              be modified to keep

                  TCP_SYNQ_HSIZE * 16 <= tcp_max_syn_backlog

              and the kernel should be recompiled.  In Linux 2.6.20, the fixed sized TTCCPP__SSYYNNQQ__HHSSIIZZEE
              was removed in favor of dynamic sizing.

       _t_c_p___m_a_x___t_w___b_u_c_k_e_t_s (integer; default: see below; since Linux 2.4)
              The maximum number of sockets in TIME_WAIT state allowed in the system.  This limit
              exists only to prevent simple denial-of-service attacks.  The default value of
              NR_FILE*2 is adjusted depending on the memory in the system.  If this number is
              exceeded, the socket is closed and a warning is printed.

       _t_c_p___m_o_d_e_r_a_t_e___r_c_v_b_u_f (Boolean; default: enabled; since Linux 2.4.17/2.6.7)
              If enabled, TCP performs receive buffer auto-tuning, attempting to automatically size
              the buffer (no greater than _t_c_p___r_m_e_m_[_2_]) to match the size required by the path for
              full throughput.

       _t_c_p___m_e_m (since Linux 2.4)
              This is a vector of 3 integers: [low, pressure, high].  These bounds, measured in
              units of the system page size, are used by TCP to track its memory usage.  The
              defaults are calculated at boot time from the amount of available memory.  (TCP can
              only use _l_o_w _m_e_m_o_r_y for this, which is limited to around 900 megabytes on 32-bit
              systems.  64-bit systems do not suffer this limitation.)

              _l_o_w    TCP doesn't regulate its memory allocation when the number of pages it has
                     allocated globally is below this number.

              _p_r_e_s_s_u_r_e
                     When the amount of memory allocated by TCP exceeds this number of pages, TCP
                     moderates its memory consumption.  This memory pressure state is exited once
                     the number of pages allocated falls below the _l_o_w mark.

              _h_i_g_h   The maximum number of pages, globally, that TCP will allocate.  This value
                     overrides any other limits imposed by the kernel.

       _t_c_p___m_t_u___p_r_o_b_i_n_g (integer; default: 0; since Linux 2.6.17)
              This parameter controls TCP Packetization-Layer Path MTU Discovery.  The following
              values may be assigned to the file:

              0  Disabled

              1  Disabled by default, enabled when an ICMP black hole detected

              2  Always enabled, use initial MSS of _t_c_p___b_a_s_e___m_s_s.

       _t_c_p___n_o___m_e_t_r_i_c_s___s_a_v_e (Boolean; default: disabled; since Linux 2.6.6)
              By default, TCP saves various connection metrics in the route cache when the
              connection closes, so that connections established in the near future can use these
              to set initial conditions.  Usually, this increases overall performance, but it may
              sometimes cause performance degradation.  If _t_c_p___n_o___m_e_t_r_i_c_s___s_a_v_e is enabled, TCP will
              not cache metrics on closing connections.

       _t_c_p___o_r_p_h_a_n___r_e_t_r_i_e_s (integer; default: 8; since Linux 2.4)
              The maximum number of attempts made to probe the other end of a connection which has
              been closed by our end.

       _t_c_p___r_e_o_r_d_e_r_i_n_g (integer; default: 3; since Linux 2.4)
              The maximum a packet can be reordered in a TCP packet stream without TCP assuming
              packet loss and going into slow start.  It is not advisable to change this number.
              This is a packet reordering detection metric designed to minimize unnecessary back
              off and retransmits provoked by reordering of packets on a connection.

       _t_c_p___r_e_t_r_a_n_s___c_o_l_l_a_p_s_e (Boolean; default: enabled; since Linux 2.2)
              Try to send full-sized packets during retransmit.

       _t_c_p___r_e_t_r_i_e_s_1 (integer; default: 3; since Linux 2.2)
              The number of times TCP will attempt to retransmit a packet on an established
              connection normally, without the extra effort of getting the network layers involved.
              Once we exceed this number of retransmits, we first have the network layer update the
              route if possible before each new retransmit.  The default is the RFC specified
              minimum of 3.

       _t_c_p___r_e_t_r_i_e_s_2 (integer; default: 15; since Linux 2.2)
              The maximum number of times a TCP packet is retransmitted in established state before
              giving up.  The default value is 15, which corresponds to a duration of approximately
              between 13 to 30 minutes, depending on the retransmission timeout.  The RFC 1122
              specified minimum limit of 100 seconds is typically deemed too short.

       _t_c_p___r_f_c_1_3_3_7 (Boolean; default: disabled; since Linux 2.2)
              Enable TCP behavior conformant with RFC 1337.  When disabled, if a RST is received in
              TIME_WAIT state, we close the socket immediately without waiting for the end of the
              TIME_WAIT period.

       _t_c_p___r_m_e_m (since Linux 2.4)
              This is a vector of 3 integers: [min, default, max].  These parameters are used by
              TCP to regulate receive buffer sizes.  TCP dynamically adjusts the size of the
              receive buffer from the defaults listed below, in the range of these values,
              depending on memory available in the system.

              _m_i_n    minimum size of the receive buffer used by each TCP socket.  The default value
                     is the system page size.  (On Linux 2.4, the default value is 4 kB, lowered to
                     PPAAGGEE__SSIIZZEE bytes in low-memory systems.)  This value is used to ensure that in
                     memory pressure mode, allocations below this size will still succeed.  This is
                     not used to bound the size of the receive buffer declared using SSOO__RRCCVVBBUUFF on a
                     socket.

              _d_e_f_a_u_l_t
                     the default size of the receive buffer for a TCP socket.  This value
                     overwrites the initial default buffer size from the generic global
                     _n_e_t_._c_o_r_e_._r_m_e_m___d_e_f_a_u_l_t defined for all protocols.  The default value is 87380
                     bytes.  (On Linux 2.4, this will be lowered to 43689 in low-memory systems.)
                     If larger receive buffer sizes are desired, this value should be increased (to
                     affect all sockets).  To employ large TCP windows, the
                     _n_e_t_._i_p_v_4_._t_c_p___w_i_n_d_o_w___s_c_a_l_i_n_g must be enabled (default).

              _m_a_x    the maximum size of the receive buffer used by each TCP socket.  This value
                     does not override the global _n_e_t_._c_o_r_e_._r_m_e_m___m_a_x.  This is not used to limit the
                     size of the receive buffer declared using SSOO__RRCCVVBBUUFF on a socket.  The default
                     value is calculated using the formula

                         max(87380, min(4 MB, _t_c_p___m_e_m[1]*PAGE_SIZE/128))

                     (On Linux 2.4, the default is 87380*2 bytes, lowered to 87380 in low-memory
                     systems).

       _t_c_p___s_a_c_k (Boolean; default: enabled; since Linux 2.2)
              Enable RFC 2018 TCP Selective Acknowledgements.

       _t_c_p___s_l_o_w___s_t_a_r_t___a_f_t_e_r___i_d_l_e (Boolean; default: enabled; since Linux 2.6.18)
              If enabled, provide RFC 2861 behavior and time out the congestion window after an
              idle period.  An idle period is defined as the current RTO (retransmission timeout).
              If disabled, the congestion window will not be timed out after an idle period.

       _t_c_p___s_t_d_u_r_g (Boolean; default: disabled; since Linux 2.2)
              If this option is enabled, then use the RFC 1122 interpretation of the TCP urgent-
              pointer field.  According to this interpretation, the urgent pointer points to the
              last byte of urgent data.  If this option is disabled, then use the BSD-compatible
              interpretation of the urgent pointer: the urgent pointer points to the first byte
              after the urgent data.  Enabling this option may lead to interoperability problems.

       _t_c_p___s_y_n___r_e_t_r_i_e_s (integer; default: 6; since Linux 2.2)
              The maximum number of times initial SYNs for an active TCP connection attempt will be
              retransmitted.  This value should not be higher than 255.  The default value is 6,
              which corresponds to retrying for up to approximately 127 seconds.  Before Linux 3.7,
              the default value was 5, which (in conjunction with calculation based on other kernel
              parameters) corresponded to approximately 180 seconds.

       _t_c_p___s_y_n_a_c_k___r_e_t_r_i_e_s (integer; default: 5; since Linux 2.2)
              The maximum number of times a SYN/ACK segment for a passive TCP connection will be
              retransmitted.  This number should not be higher than 255.

       _t_c_p___s_y_n_c_o_o_k_i_e_s (integer; default: 1; since Linux 2.2)
              Enable TCP syncookies.  The kernel must be compiled with CCOONNFFIIGG__SSYYNN__CCOOOOKKIIEESS.  The
              syncookies feature attempts to protect a socket from a SYN flood attack.  This should
              be used as a last resort, if at all.  This is a violation of the TCP protocol, and
              conflicts with other areas of TCP such as TCP extensions.  It can cause problems for
              clients and relays.  It is not recommended as a tuning mechanism for heavily loaded
              servers to help with overloaded or misconfigured conditions.  For recommended
              alternatives see _t_c_p___m_a_x___s_y_n___b_a_c_k_l_o_g, _t_c_p___s_y_n_a_c_k___r_e_t_r_i_e_s, and _t_c_p___a_b_o_r_t___o_n___o_v_e_r_f_l_o_w.
              Set to one of the following values:

              0  Disable TCP syncookies.

              1  Send out syncookies when the syn backlog queue of a socket overflows.

              2  (since Linux 3.12) Send out syncookies unconditionally.  This can be useful for
                 network testing.

       _t_c_p___t_i_m_e_s_t_a_m_p_s (integer; default: 1; since Linux 2.2)
              Set to one of the following values to enable or disable RFC 1323 TCP timestamps:

              0  Disable timestamps.

              1  Enable timestamps as defined in RFC1323 and use random offset for each connection
                 rather than only using the current time.

              2  As for the value 1, but without random offsets.  Setting _t_c_p___t_i_m_e_s_t_a_m_p_s to this
                 value is meaningful since Linux 4.10.

       _t_c_p___t_s_o___w_i_n___d_i_v_i_s_o_r (integer; default: 3; since Linux 2.6.9)
              This parameter controls what percentage of the congestion window can be consumed by a
              single TCP Segmentation Offload (TSO) frame.  The setting of this parameter is a
              tradeoff between burstiness and building larger TSO frames.

       _t_c_p___t_w___r_e_c_y_c_l_e (Boolean; default: disabled; Linux 2.4 to 4.11)
              Enable fast recycling of TIME_WAIT sockets.  Enabling this option is not recommended
              as the remote IP may not use monotonically increasing timestamps (devices behind NAT,
              devices with per-connection timestamp offsets).  See RFC 1323 (PAWS) and RFC 6191.

       _t_c_p___t_w___r_e_u_s_e (Boolean; default: disabled; since Linux 2.4.19/2.6)
              Allow to reuse TIME_WAIT sockets for new connections when it is safe from protocol
              viewpoint.  It should not be changed without advice/request of technical experts.

       _t_c_p___v_e_g_a_s___c_o_n_g___a_v_o_i_d (Boolean; default: disabled; Linux 2.2 to 2.6.13)
              Enable TCP Vegas congestion avoidance algorithm.  TCP Vegas is a sender-side-only
              change to TCP that anticipates the onset of congestion by estimating the bandwidth.
              TCP Vegas adjusts the sending rate by modifying the congestion window.  TCP Vegas
              should provide less packet loss, but it is not as aggressive as TCP Reno.

       _t_c_p___w_e_s_t_w_o_o_d (Boolean; default: disabled; Linux 2.4.26/2.6.3 to 2.6.13)
              Enable TCP Westwood+ congestion control algorithm.  TCP Westwood+ is a sender-side-
              only modification of the TCP Reno protocol stack that optimizes the performance of
              TCP congestion control.  It is based on end-to-end bandwidth estimation to set
              congestion window and slow start threshold after a congestion episode.  Using this
              estimation, TCP Westwood+ adaptively sets a slow start threshold and a congestion
              window which takes into account the bandwidth used at the time congestion is
              experienced.  TCP Westwood+ significantly increases fairness with respect to TCP Reno
              in wired networks and throughput over wireless links.

       _t_c_p___w_i_n_d_o_w___s_c_a_l_i_n_g (Boolean; default: enabled; since Linux 2.2)
              Enable RFC 1323 TCP window scaling.  This feature allows the use of a large window (>
              64 kB) on a TCP connection, should the other end support it.  Normally, the 16 bit
              window length field in the TCP header limits the window size to less than 64 kB.  If
              larger windows are desired, applications can increase the size of their socket
              buffers and the window scaling option will be employed.  If _t_c_p___w_i_n_d_o_w___s_c_a_l_i_n_g is
              disabled, TCP will not negotiate the use of window scaling with the other end during
              connection setup.

       _t_c_p___w_m_e_m (since Linux 2.4)
              This is a vector of 3 integers: [min, default, max].  These parameters are used by
              TCP to regulate send buffer sizes.  TCP dynamically adjusts the size of the send
              buffer from the default values listed below, in the range of these values, depending
              on memory available.

              _m_i_n    Minimum size of the send buffer used by each TCP socket.  The default value is
                     the system page size.  (On Linux 2.4, the default value is 4 kB.)  This value
                     is used to ensure that in memory pressure mode, allocations below this size
                     will still succeed.  This is not used to bound the size of the send buffer
                     declared using SSOO__SSNNDDBBUUFF on a socket.

              _d_e_f_a_u_l_t
                     The default size of the send buffer for a TCP socket.  This value overwrites
                     the initial default buffer size from the generic global
                     _/_p_r_o_c_/_s_y_s_/_n_e_t_/_c_o_r_e_/_w_m_e_m___d_e_f_a_u_l_t defined for all protocols.  The default value
                     is 16 kB.  If larger send buffer sizes are desired, this value should be
                     increased (to affect all sockets).  To employ large TCP windows, the
                     _/_p_r_o_c_/_s_y_s_/_n_e_t_/_i_p_v_4_/_t_c_p___w_i_n_d_o_w___s_c_a_l_i_n_g must be set to a nonzero value
                     (default).

              _m_a_x    The maximum size of the send buffer used by each TCP socket.  This value does
                     not override the value in _/_p_r_o_c_/_s_y_s_/_n_e_t_/_c_o_r_e_/_w_m_e_m___m_a_x.  This is not used to
                     limit the size of the send buffer declared using SSOO__SSNNDDBBUUFF on a socket.  The
                     default value is calculated using the formula

                         max(65536, min(4 MB, _t_c_p___m_e_m[1]*PAGE_SIZE/128))

                     (On Linux 2.4, the default value is 128 kB, lowered 64 kB depending on low-
                     memory systems.)

       _t_c_p___w_o_r_k_a_r_o_u_n_d___s_i_g_n_e_d___w_i_n_d_o_w_s (Boolean; default: disabled; since Linux 2.6.26)
              If enabled, assume that no receipt of a window-scaling option means that the remote
              TCP is broken and treats the window as a signed quantity.  If disabled, assume that
              the remote TCP is not broken even if we do not receive a window scaling option from
              it.

   SSoocckkeett ooppttiioonnss
       To set or get a TCP socket option, call ggeettssoocckkoopptt(2) to read or sseettssoocckkoopptt(2) to write the
       option with the option level argument set to IIPPPPRROOTTOO__TTCCPP.  Unless otherwise noted, _o_p_t_v_a_l is
       a pointer to an _i_n_t.  In addition, most IIPPPPRROOTTOO__IIPP socket options are valid on TCP sockets.
       For more information see iipp(7).

       Following is a list of TCP-specific socket options.  For details of some other socket
       options that are also applicable for TCP sockets, see ssoocckkeett(7).

       TTCCPP__CCOONNGGEESSTTIIOONN (since Linux 2.6.13)
              The argument for this option is a string.  This option allows the caller to set the
              TCP congestion control algorithm to be used, on a per-socket basis.  Unprivileged
              processes are restricted to choosing one of the algorithms in
              _t_c_p___a_l_l_o_w_e_d___c_o_n_g_e_s_t_i_o_n___c_o_n_t_r_o_l (described above).  Privileged processes
              (CCAAPP__NNEETT__AADDMMIINN) can choose from any of the available congestion-control algorithms
              (see the description of _t_c_p___a_v_a_i_l_a_b_l_e___c_o_n_g_e_s_t_i_o_n___c_o_n_t_r_o_l above).

       TTCCPP__CCOORRKK (since Linux 2.2)
              If set, don't send out partial frames.  All queued partial frames are sent when the
              option is cleared again.  This is useful for prepending headers before calling
              sseennddffiillee(2), or for throughput optimization.  As currently implemented, there is a
              200 millisecond ceiling on the time for which output is corked by TTCCPP__CCOORRKK.  If this
              ceiling is reached, then queued data is automatically transmitted.  This option can
              be combined with TTCCPP__NNOODDEELLAAYY only since Linux 2.5.71.  This option should not be used
              in code intended to be portable.

       TTCCPP__DDEEFFEERR__AACCCCEEPPTT (since Linux 2.4)
              Allow a listener to be awakened only when data arrives on the socket.  Takes an
              integer value (seconds), this can bound the maximum number of attempts TCP will make
              to complete the connection.  This option should not be used in code intended to be
              portable.

       TTCCPP__IINNFFOO (since Linux 2.4)
              Used to collect information about this socket.  The kernel returns a _s_t_r_u_c_t _t_c_p___i_n_f_o
              as defined in the file _/_u_s_r_/_i_n_c_l_u_d_e_/_l_i_n_u_x_/_t_c_p_._h.  This option should not be used in
              code intended to be portable.

       TTCCPP__KKEEEEPPCCNNTT (since Linux 2.4)
              The maximum number of keepalive probes TCP should send before dropping the
              connection.  This option should not be used in code intended to be portable.

       TTCCPP__KKEEEEPPIIDDLLEE (since Linux 2.4)
              The time (in seconds) the connection needs to remain idle before TCP starts sending
              keepalive probes, if the socket option SSOO__KKEEEEPPAALLIIVVEE has been set on this socket.
              This option should not be used in code intended to be portable.

       TTCCPP__KKEEEEPPIINNTTVVLL (since Linux 2.4)
              The time (in seconds) between individual keepalive probes.  This option should not be
              used in code intended to be portable.

       TTCCPP__LLIINNGGEERR22 (since Linux 2.4)
              The lifetime of orphaned FIN_WAIT2 state sockets.  This option can be used to
              override the system-wide setting in the file _/_p_r_o_c_/_s_y_s_/_n_e_t_/_i_p_v_4_/_t_c_p___f_i_n___t_i_m_e_o_u_t for
              this socket.  This is not to be confused with the ssoocckkeett(7) level option SSOO__LLIINNGGEERR.
              This option should not be used in code intended to be portable.

       TTCCPP__MMAAXXSSEEGG
              The maximum segment size for outgoing TCP packets.  In Linux 2.2 and earlier, and in
              Linux 2.6.28 and later, if this option is set before connection establishment, it
              also changes the MSS value announced to the other end in the initial packet.  Values
              greater than the (eventual) interface MTU have no effect.  TCP will also impose its
              minimum and maximum bounds over the value provided.

       TTCCPP__NNOODDEELLAAYY
              If set, disable the Nagle algorithm.  This means that segments are always sent as
              soon as possible, even if there is only a small amount of data.  When not set, data
              is buffered until there is a sufficient amount to send out, thereby avoiding the
              frequent sending of small packets, which results in poor utilization of the network.
              This option is overridden by TTCCPP__CCOORRKK; however, setting this option forces an
              explicit flush of pending output, even if TTCCPP__CCOORRKK is currently set.

       TTCCPP__QQUUIICCKKAACCKK (since Linux 2.4.4)
              Enable quickack mode if set or disable quickack mode if cleared.  In quickack mode,
              acks are sent immediately, rather than delayed if needed in accordance to normal TCP
              operation.  This flag is not permanent, it only enables a switch to or from quickack
              mode.  Subsequent operation of the TCP protocol will once again enter/leave quickack
              mode depending on internal protocol processing and factors such as delayed ack
              timeouts occurring and data transfer.  This option should not be used in code
              intended to be portable.

       TTCCPP__SSYYNNCCNNTT (since Linux 2.4)
              Set the number of SYN retransmits that TCP should send before aborting the attempt to
              connect.  It cannot exceed 255.  This option should not be used in code intended to
              be portable.

       TTCCPP__UUSSEERR__TTIIMMEEOOUUTT (since Linux 2.6.37)
              This option takes an _u_n_s_i_g_n_e_d _i_n_t as an argument.  When the value is greater than 0,
              it specifies the maximum amount of time in milliseconds that transmitted data may
              remain unacknowledged, or bufferred data may remain untransmitted (due to zero window
              size) before TCP will forcibly close the corresponding connection and return
              EETTIIMMEEDDOOUUTT to the application.  If the option value is specified as 0, TCP will use
              the system default.

              Increasing user timeouts allows a TCP connection to survive extended periods without
              end-to-end connectivity.  Decreasing user timeouts allows applications to "fail
              fast", if so desired.  Otherwise, failure may take up to 20 minutes with the current
              system defaults in a normal WAN environment.

              This option can be set during any state of a TCP connection, but is effective only
              during the synchronized states of a connection (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2,
              CLOSE-WAIT, CLOSING, and LAST-ACK).  Moreover, when used with the TCP keepalive
              (SSOO__KKEEEEPPAALLIIVVEE) option, TTCCPP__UUSSEERR__TTIIMMEEOOUUTT will override keepalive to determine when to
              close a connection due to keepalive failure.

              The option has no effect on when TCP retransmits a packet, nor when a keepalive probe
              is sent.

              This option, like many others, will be inherited by the socket returned by aacccceepptt(2),
              if it was set on the listening socket.

              Further details on the user timeout feature can be found in RFC 793 and RFC 5482
              ("TCP User Timeout Option").

       TTCCPP__WWIINNDDOOWW__CCLLAAMMPP (since Linux 2.4)
              Bound the size of the advertised window to this value.  The kernel imposes a minimum
              size of SOCK_MIN_RCVBUF/2.  This option should not be used in code intended to be
              portable.

   SSoocckkeettss AAPPII
       TCP provides limited support for out-of-band data, in the form of (a single byte of) urgent
       data.  In Linux this means if the other end sends newer out-of-band data the older urgent
       data is inserted as normal data into the stream (even when SSOO__OOOOBBIINNLLIINNEE is not set).  This
       differs from BSD-based stacks.

       Linux uses the BSD compatible interpretation of the urgent pointer field by default.  This
       violates RFC 1122, but is required for interoperability with other stacks.  It can be
       changed via _/_p_r_o_c_/_s_y_s_/_n_e_t_/_i_p_v_4_/_t_c_p___s_t_d_u_r_g.

       It is possible to peek at out-of-band data using the rreeccvv(2) MMSSGG__PPEEEEKK flag.

       Since version 2.4, Linux supports the use of MMSSGG__TTRRUUNNCC in the _f_l_a_g_s argument of rreeccvv(2) (and
       rreeccvvmmssgg(2)).  This flag causes the received bytes of data to be discarded, rather than
       passed back in a caller-supplied buffer.  Since Linux 2.4.4, MMSSGG__TTRRUUNNCC also has this effect
       when used in conjunction with MMSSGG__OOOOBB to receive out-of-band data.

   IIooccttllss
       The following iiooccttll(2) calls return information in _v_a_l_u_e.  The correct syntax is:

              iinntt _v_a_l_u_e;;
              _e_r_r_o_r == iiooccttll((_t_c_p___s_o_c_k_e_t,, _i_o_c_t_l___t_y_p_e,, &&_v_a_l_u_e));;

       _i_o_c_t_l___t_y_p_e is one of the following:

       SSIIOOCCIINNQQ
              Returns the amount of queued unread data in the receive buffer.  The socket must not
              be in LISTEN state, otherwise an error (EEIINNVVAALL) is returned.  SSIIOOCCIINNQQ is defined in
              _<_l_i_n_u_x_/_s_o_c_k_i_o_s_._h_>.  Alternatively, you can use the synonymous FFIIOONNRREEAADD, defined in
              _<_s_y_s_/_i_o_c_t_l_._h_>.

       SSIIOOCCAATTMMAARRKK
              Returns true (i.e., _v_a_l_u_e is nonzero) if the inbound data stream is at the urgent
              mark.

              If the SSOO__OOOOBBIINNLLIINNEE socket option is set, and SSIIOOCCAATTMMAARRKK returns true, then the next
              read from the socket will return the urgent data.  If the SSOO__OOOOBBIINNLLIINNEE socket option
              is not set, and SSIIOOCCAATTMMAARRKK returns true, then the next read from the socket will
              return the bytes following the urgent data (to actually read the urgent data requires
              the rreeccvv((MMSSGG__OOOOBB)) flag).

              Note that a read never reads across the urgent mark.  If an application is informed
              of the presence of urgent data via sseelleecctt(2) (using the _e_x_c_e_p_t_f_d_s argument) or
              through delivery of a SSIIGGUURRGG signal, then it can advance up to the mark using a loop
              which repeatedly tests SSIIOOCCAATTMMAARRKK and performs a read (requesting any number of
              bytes) as long as SSIIOOCCAATTMMAARRKK returns false.

       SSIIOOCCOOUUTTQQ
              Returns the amount of unsent data in the socket send queue.  The socket must not be
              in LISTEN state, otherwise an error (EEIINNVVAALL) is returned.  SSIIOOCCOOUUTTQQ is defined in
              _<_l_i_n_u_x_/_s_o_c_k_i_o_s_._h_>.  Alternatively, you can use the synonymous TTIIOOCCOOUUTTQQ, defined in
              _<_s_y_s_/_i_o_c_t_l_._h_>.

   EErrrroorr hhaannddlliinngg
       When a network error occurs, TCP tries to resend the packet.  If it doesn't succeed after
       some time, either EETTIIMMEEDDOOUUTT or the last received error on this connection is reported.

       Some applications require a quicker error notification.  This can be enabled with the
       IIPPPPRROOTTOO__IIPP level IIPP__RREECCVVEERRRR socket option.  When this option is enabled, all incoming errors
       are immediately passed to the user program.  Use this option with care — it makes TCP less
       tolerant to routing changes and other normal network conditions.

EERRRROORRSS
       EEAAFFNNOOTTSSUUPPPPOORRTT
              Passed socket address type in _s_i_n___f_a_m_i_l_y was not AAFF__IINNEETT.

       EEPPIIPPEE  The other end closed the socket unexpectedly or a read is executed on a shut down
              socket.

       EETTIIMMEEDDOOUUTT
              The other end didn't acknowledge retransmitted data after some time.

       Any errors defined for iipp(7) or the generic socket layer may also be returned for TCP.

VVEERRSSIIOONNSS
       Support for Explicit Congestion Notification, zero-copy sseennddffiillee(2), reordering support and
       some SACK extensions (DSACK) were introduced in 2.4.  Support for forward acknowledgement
       (FACK), TIME_WAIT recycling, and per-connection keepalive socket options were introduced in
       2.3.

BBUUGGSS
       Not all errors are documented.

       IPv6 is not described.

SSEEEE AALLSSOO
       aacccceepptt(2), bbiinndd(2), ccoonnnneecctt(2), ggeettssoocckkoopptt(2), lliisstteenn(2), rreeccvvmmssgg(2), sseennddffiillee(2),
       sseennddmmssgg(2), ssoocckkeett(2), iipp(7), ssoocckkeett(7)

       The kernel source file _D_o_c_u_m_e_n_t_a_t_i_o_n_/_n_e_t_w_o_r_k_i_n_g_/_i_p_-_s_y_s_c_t_l_._t_x_t.

       RFC 793 for the TCP specification.
       RFC 1122 for the TCP requirements and a description of the Nagle algorithm.
       RFC 1323 for TCP timestamp and window scaling options.
       RFC 1337 for a description of TIME_WAIT assassination hazards.
       RFC 3168 for a description of Explicit Congestion Notification.
       RFC 2581 for TCP congestion control algorithms.
       RFC 2018 and RFC 2883 for SACK and extensions to SACK.



Linux                                        2021-03-22                                      TCP(7)
